@using Jibini.CommonUtil.Algorithms
@using Jibini.CommonUtil.DataStructures

@{
    visited.Clear();
    cycles.Clear();
    coords.Clear();

    var (svg, _depth, _height) = FsaNode(Grammar);
    width = 50 + 80 * (_depth - 1);
    height = _height;

    <div class="d-block">
        <svg style="width: @(width)px;height: @(height)px;filter: drop-shadow(1px 2px 3px grey);position: relative;z-index: 2;">
            <defs>
                <marker id="triangleBlack"
                        viewBox="0 0 10 10"
                        refX="27"
                        refY="5"
                        markerUnits="strokeWidth"
                        markerWidth="10"
                        markerHeight="10"
                        orient="auto">
                    <path d="M 0 0 L 10 5 L 0 10 z" fill="black" />
                </marker>
            </defs>

            @svg(0, 0)
        </svg>

        <div style="width: @(width)px;height: @(height)px;z-index: 1;display: block;position: absolute;margin-top: -@(height)px;">
            <svg style="width: 100%;height: 100%;filter: drop-shadow(1px 2px 3px grey);">
                <marker id="triangleBlue"
                        viewBox="0 0 10 10"
                        refX="22"
                        refY="5"
                        markerUnits="strokeWidth"
                        markerWidth="5"
                        markerHeight="5"
                        orient="auto">
                    <path d="M 0 0 L 10 5 L 0 10 z" fill="blue" />
                </marker>
                @foreach (var (from, to) in cycles)
                {
                    var (fromX, fromY) = coords[from];
                    var (toX, toY) = coords[to];

                    <line x1="@(fromX + 25)" x2="@(toX + 25)"
                          y1="@(fromY + 25)" y2="@(toY + 25)"
                          stroke="blue"
                          stroke-dasharray="5,5"
                          stroke-width="2.4"
                          marker-end="url(#triangleBlue)" />
                }
            </svg>
        </div>
    </div>
}

@code {
    private (Func<decimal, decimal, RenderFragment> svg, decimal depth, decimal height) FsaNode(Fsa node)
    {
        visited.Add(node);
        var _neighbors = node.Next
            .Select((kv) => (c: (char?)kv.Key, n: kv.Value))
            .Union(node.Epsilon
                .Select((it) => (c: null as char?, n: it)))
            .GroupBy((it) => visited.Contains(it.n))
            .ToDictionary((it) => it.Key, (it) => it.ToList());
        var neighbors = _neighbors.GetValueOrDefault(false, new())
            .DistinctBy((it) => it.n)
            .ToList();
        var already = _neighbors.GetValueOrDefault(true, new());

        foreach (var n in neighbors)
        {
            visited.Add(n.n);
        }
        cycles.AddRange(already.Select((it) => (node, it.n)));

        var nextFragments = neighbors
            .Select((it) => FsaNode(it.n))
            .ToList();
        var height = Math.Max(50, nextFragments.Sum((it) => it.height));
        var depth = nextFragments.Select((it) => it.depth).DefaultIfEmpty(0).Max() + 1;

        var partColors = PartitionColors();
        string determineColor(Fsa node)
        {
            if (Partitions.Count > 0)
                try
                {
                    return partColors[groupIndices[node]];
                } catch (Exception)
                {
                }
            if (removed.Contains(node))
                return "#d76666";
            if (additions.Contains(node))
                return "#71cb6f";
            if (Highlight.Contains(node))
                return "lightgrey";
            return "";
        }

        return (
            (x, y) =>
            {
                var _y = y;
                y += height / 2 - 25;
                coords[node] = (x, y);

                return
                @<g>

                    @foreach (var (svg, _, height) in nextFragments)
                    {
                        <line x1="@(x + 25)" x2="@(x + 25 + 80)"
                            y1="@(y + 25)" y2="@(_y + 25 + (height / 2 - 25))"
                            stroke="black"
                            marker-end="url(#triangleBlack)" />

                        @svg(x + 80, _y)
                        _y += height;
                    }

                    <circle cx="@(x + 25)"
                            cy="@(y + 25)"
                            r="18"
                            stroke="@(node.Accepts.Count > 0 ? "green" : "")"
                            stroke-width="3"
                            fill="@determineColor(node)" />
                    <text x="@(x + 25 - 5)"
                            y="@(y + 25 + 6)"
                            fill="white"
                            font-size="20">
                        @(node.Letter == '\0'
                            ? ""
                            : node.Letter)
                    </text>

                </g>;
            },
            depth,
            height);
    }

    [Parameter]
    public Fsa Grammar { get; set; }

    private HashSet<Fsa> additions = new();
    private HashSet<Fsa> removed = new();
    private HashSet<Fsa> _highlight = new();
    private List<List<Fsa>> _partitions = new();
    private Dictionary<Fsa, int> groupIndices = new();

    [Parameter]
    public HashSet<Fsa> Highlight { get => _highlight; set
    {
        var _additions = value
            .Where((it) => !_highlight.Contains(it))
            .ToHashSet();
        var _removed = _highlight
            .Where((it) => !value.Contains(it))
            .ToHashSet();
        if (_additions.Count > 0 || _removed.Count > 0)
        {
            additions = _additions;
            removed = _removed;
            _highlight = value;
        }
    }}

    [Parameter]
    public List<List<Fsa>> Partitions { get => _partitions; set
    {
        _partitions = value;
        groupIndices = value
            .Select((it, i) => (it, i))
            .SelectMany((it) => it.it.Select((_it) => (_it, it.i)))
            .ToDictionary((it) => it._it, (it) => it.i);
    }}

    private List<string> PartitionColors()
    {
        double period = 2.0d * Math.PI;
        double offsetPerRgb = period / 3;
        double offsetPerPart = period / _partitions.Count;

        return _partitions
            .AssignColors(alternatePhases: false, washOut: true)
            .Select((it) =>
            {
                return $"rgba({it.color.R}, {it.color.G}, {it.color.B}, 1.0)";
            })
            .ToList();
    }

    private HashSet<Fsa> visited { get; set; } = new();
    private List<(Fsa, Fsa)> cycles { get; set; } = new();
    private decimal width, height;
    private Dictionary<Fsa, (decimal, decimal)> coords = new();
}
