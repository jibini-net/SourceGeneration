using Newtonsoft.Json;
using SourceGenerator.Grammar;
using System.Diagnostics;
using System.Runtime.Serialization.Formatters.Binary;

namespace SourceGenerator;

using static Token;

internal class Program
{
    public static void Main(string[] args)
    {
        if (args.Length != 1)
        {
            Console.Error.WriteLine("Usage: SourceGenerator.exe {ModelFile}");
            Process.GetCurrentProcess().Kill();
        }
        var sourceFile = args[0];
        Console.WriteLine("/* DO NOT EDIT THIS FILE */");

        var initTime = DateTime.Now;
        var binary = new BinaryFormatter();
        Fsa dfa;
        if (File.Exists("GrammarDfaCache.bin"))
        {
            using var inStream = File.OpenRead("GrammarDfaCache.bin");
#pragma warning disable SYSLIB0011
            dfa = (Fsa)binary.Deserialize(inStream);
#pragma warning restore SYSLIB0011

            Console.WriteLine($"// DFA RESTORED IN {(DateTime.Now - initTime).TotalMilliseconds}ms");
        } else
        {
            var letters = "a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z";
            var capLetters = letters.ToUpperInvariant();
            var numbers = "0|1|2|3|4|5|6|7|8|9";
            var cSharpType = "\\<|\\>|\\[|\\]|\\.|\\?";
            var word = $"({letters}|{capLetters}|_)+(|({letters}|{capLetters}|{numbers}|{cSharpType}|_)+)";

            var nfa = new Fsa();
            nfa.Build("schema",     (int)Schema);
            nfa.Build("partial",    (int)Partial);
            nfa.Build("repo",       (int)Repo);
            nfa.Build("service",    (int)Service);
            nfa.Build("json",       (int)Json);
            nfa.Build(word,         (int)Ident);
            nfa.Build("\\{",        (int)LCurly);
            nfa.Build("\\}",        (int)RCurly);
            nfa.Build("\\(",        (int)LParen);
            nfa.Build("\\)",        (int)RParen);
            nfa.Build("\\,",        (int)Comma);
            nfa.Build("\\.\\.\\.",  (int)Splat);
            nfa.Build("\\=",        (int)Assign);
            nfa.Build("\\=\\>",     (int)Arrow);
            nfa.Build("( |\n|\r|\t)+", 9999);

            Console.WriteLine($"// INITIAL NFA TRAINED AT {(DateTime.Now - initTime).TotalMilliseconds}ms");

            // Significant performance improvement after initial training
            dfa = nfa.ConvertToDfa();
            // In case multiple processes are compiling cache
            var tempFile = $"GrammarDfaCache-{Guid.NewGuid()}.bin";
            using (var outStream = File.OpenWrite(tempFile))
            {
#pragma warning disable SYSLIB0011
                binary.Serialize(outStream, dfa);
#pragma warning restore SYSLIB0011
            }

            // Try to place the cache in the correct place; ignore errors
            try
            {
                File.Move(tempFile, "GrammarDfaCache.bin");
            } catch (Exception)
            {
                File.Delete(tempFile);
            }

            Console.WriteLine($"// DFA INITIALIZED IN {(DateTime.Now - initTime).TotalMilliseconds}ms");
        }

        var startTime = DateTime.Now;
        Console.WriteLine($"// GENERATED FROM '{sourceFile}' AT {startTime:yyyy-MM-dd HH:mm:ss}");
        
        Console.WriteLine("#nullable disable");
        Console.WriteLine("namespace Generated;");

        if (!File.Exists(sourceFile))
        {
            throw new Exception($"Could not find '{sourceFile}'");
        }
        var source = new TokenStream()
        {
            Source = File.ReadAllText(sourceFile),
            Grammar = dfa
        };

        var modelName = Path.GetFileNameWithoutExtension(sourceFile);
        Console.WriteLine($"public class {modelName}");
        Console.WriteLine("{");

        try
        {
            TopLevelGrammar.Match(source, modelName);
        } catch (Exception ex)
        {
            int lineNumber = 1, prevLine = 0;
            for (int i = 0; i <= source.Offset && i < source.Source.Length; i++)
            {
                if (source.Source[i] == '\n')
                {
                    lineNumber++;
                    prevLine = i;
                }
            }

            Console.Error.WriteLine("{0}:{1}:{2} - {3}",
                sourceFile,
                lineNumber,
                source.Offset - prevLine + 1,
                ex.Message);
            Process.GetCurrentProcess().Kill();
        }

        Console.WriteLine("}");
        Console.WriteLine($"// GENERATED IN {(DateTime.Now - startTime).TotalMilliseconds}ms");
    }
}
