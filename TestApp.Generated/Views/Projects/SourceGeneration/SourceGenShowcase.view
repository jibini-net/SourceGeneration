state {
}

interface {
}

div(| class = {"d-flex flex-row flex-wrap"} |
	div(| class = {"col-12 col-md-8 bg-dark border border-light p-3"} |
		h4({"Source Generation"})
		hr()
		p(
			<">
			Generated code allows developers to skip over tedium and keep focused
			on important design details.
			</">
		)
		p(| class = {"mb-4"} |
			<">
			My source generation platform aims to establish a definitive .NET project
			architecture of declarative descriptor languages. Several backend and
			frontend tasks follow patterns which can be boilerplated from a source
			descriptor document.
			</">
		)
		SourceGenTabs()
		p(| class = {"my-4"} |
			<">
			The developer can build large portions of the application codebase from
			fewer succinct lines leveraging structured generation patterns.
			</">
		)
		h4({"Finite State Machines"})
		hr()
		div(|
			id = {"fsa-preview"},
			class = {"ms-3 mb-3"}
			|
			iframe(| src = {sp
				.GetRequiredService<TestApp.Services.ILinkPathGenerator>()
				.GetNamed("Fsa")} |)
			i(| id = {"fsa-caption"} |
				{"(above: construction and minimization of a finite state automaton)"}
			)
			a(|
				href = {sp
					.GetRequiredService<TestApp.Services.ILinkPathGenerator>()
					.GetNamed("Fsa")},
				target = {"_blank"},
				id = {"fsa-link"},
				title = {"Open in new tab"}
				|
				h3(| class = {"fas fa-external-link-alt"} |)
			)
		)
		p(
			<">
			My descriptor language parser applies recursive descent parsing using a custom
			implementation of regular expression.
			</">
		)
		p(
			<">
			Patterns can be specified with a subset of the Basic Regular Expression
			language (BRE) and are adapted to a node representation.
			</">
		)
		c(
			pre(| class = {"code-preview"} |
<">var nfa = new Fsa();
nfa.Build("(a|b|c)+",   (int)Token1);
nfa.Build("int|long",   (int)Token2);
nfa.Build("{|}",        (int)Token3);
...</">
			)
		)
		p(
			<">
			Furthermore, several Nondeterministic Finite Automata (NFAs) can be formed from
			several regex expressions to match a corresponding set of tokens in a language.
			</">
		)
		p(| class = {"mb-4"} |
			<">
			All possible tokens which can be matched by the state machine are knit
			into one NFA, which can be used to match tokens as-is (using non-deterministic
			breadth-first evaluation of the NFA)
			</">
		)
		c(
			pre(| class = {"code-preview"} |
<">var (token, match) = nfa.Search(source, offset);</">
			)
		)
		p(
			<">
			or further optimized using DFA conversion
			and equivalence partioning.
			</">
		)
		c(
			pre(| class = {"code-preview"} |
<">var dfa = nfa.ConvertToDfa().MinimizeDfa();
var (token, match) = dfa.Search(source, offset);</">
			)
		)
	)
	div(| class = {"col-12 col-md-4"} |
		div(| class = {"bg-light p-3 text-dark"} |
			h4({"This Site"})
			p(
				<">
				My portfolio site is written in my own reactive declarative markup
				language, serving as a testbed for new source generation features.
				</">
			)
			p({"Some demos:"})
			DemoTabs(|
				title = {"Up/Down"},
				prefix = {"up-down"}
				|
				UpDownDemo()
<">state {
	int count
}

interface {
	Increment(),
	Decrement()
}

div(| class = {"d-flex flex-row"} |
	div(| class = {"my-auto"} |
		{"Count: " + count}
	)
	button(|
		class = {"btn btn-danger ms-2"},
		onclick = {"dispatch(this, 'Decrement');"}
		|
		{"-"}
	)
	button(|
		class = {"btn btn-success ms-2"},
		onclick = {"dispatch(this, 'Increment');"}
		|
		{"+"}
	)
)</">
<">using Generated;

namespace TestApp.Views;

public class UpDownDemo : UpDownDemoBase
{
		public UpDownDemo(IServiceProvider sp) : base(sp)
		{
		}

		public override void Decrement()
		{
				count--;
		}

		public override void Increment()
		{
				count++;
		}
}</">
			)
			p(| class = {"mt-3"} |
				<">
				Serverside code is generated to render HTML for the component.
				Controller endpoints are also generated corresponding to any actions
				within the component interface.
				</">
			)
			p(
				<">
				Some minimal JS swaps out DOM elements to reactively update the
				page to reflect its latest state.
				</">
			)
			DemoTabs(|
				title = {"Table Rows"},
				prefix = {"table-rows"}
				|
				TableRowDemo()
<">state {
	List<string> rows = {new() { "Row" }}
}

interface {
	Add(string row),
	Remove(int index),
	MoveUp(int index),
	MoveDown(int index)
}

table(| class = {"table table-striped table-bordered"} |
	colgroup(
		col(| style = {"width: 70%;"} |)
		col(| style = {"width: 30%;"} |)
	)
	thead(
		tr(
			th({"Value"})
			th({"Actions"})
		)
	)
	tbody(
		tr(
			td(
				input(|
					type = {"text"},
					id = {"table-add"},
					class = {"form-control"},
					value = {rows.Count >= 5 ? "Max 5 rows" : ""},
					disabled = {rows.Count >= 5}
					|)
			)
			td(
				button(|
					type = {"button"},
					class = {"btn btn-outline-primary"},
					onclick = {"dispatch(this, 'Add', { row: $('#table-add').val() });"},
					disabled = {rows.Count >= 5}
					|
					{"Add"}
				)
			)
		)
		foreach({var (row, i) in rows.Select((it, i) => (it, i))}

			tr(
				td({string.IsNullOrEmpty(row) ? "Blank!" : row})
				td(
					i(|
						class = {"fa fa-arrow-up me-2"},
						style = {"cursor: pointer;"},
						onclick = {"dispatch(this, 'MoveUp', { index: " + i + " });"}
						|)
					i(|
						class = {"fa fa-arrow-down me-2"},
						style = {"cursor: pointer;"},
						onclick = {"dispatch(this, 'MoveDown', { index: " + i + " });"}
						|)
					i(|
						class = {"fa fa-trash me-2"},
						style = {"cursor: pointer;"},
						onclick = {"dispatch(this, 'Remove', { index: " + i + " });"}
						|)
				)
			)
		)
	)
)</">
<">using Generated;

namespace TestApp.Views;

public class TableRowDemo : TableRowDemoBase
{
		public TableRowDemo(IServiceProvider sp) : base(sp)
		{
		}

		public override void Add(string row)
		{
				rows.Add(row);
		}

		public override void MoveDown(int index)
		{
				if (index >= rows.Count - 1)
				{
						return;
				}
				var temp = rows[index];
				rows[index] = rows[index + 1];
				rows[index + 1] = temp;
		}

		public override void MoveUp(int index)
		{
				if (index <= 0)
				{
						return;
				}
				var temp = rows[index];
				rows[index] = rows[index - 1];
				rows[index - 1] = temp;
		}

		public override void Remove(int index)
		{
				rows.RemoveAt(index);
		}
}</">
			)
		)
	)
)
